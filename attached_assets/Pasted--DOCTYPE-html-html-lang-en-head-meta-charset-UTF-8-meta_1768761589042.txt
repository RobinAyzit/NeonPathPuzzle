<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>One Line Master</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        :root {
            --primary: #00f3ff;
            --primary-dark: #00a8ff;
            --secondary: #8a2be2;
            --background: #0a0f23;
            --surface: rgba(10, 20, 40, 0.9);
            --success: #00ff88;
            --warning: #ff9500;
            --error: #ff5555;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0a0f1e 0%, #1a1a3e 50%, #0f1528 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
            padding: 10px;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 243, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(138, 43, 226, 0.05) 0%, transparent 50%);
            animation: bgPulse 15s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes bgPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1/1;
            background: linear-gradient(145deg, rgba(10, 15, 35, 0.95), rgba(20, 25, 50, 0.9));
            border-radius: 24px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(0, 150, 255, 0.15);
            overflow: hidden;
            touch-action: none;
            margin-bottom: 15px;
            border: 2px solid rgba(0, 180, 255, 0.3);
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(15, 20, 40, 0.95), rgba(5, 10, 25, 0.98));
            border-radius: 20px;
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            background: linear-gradient(180deg, rgba(10, 15, 35, 0.8) 0%, transparent 100%);
        }
        
        #level-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        #level-display {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 50, 100, 0.85));
            padding: 10px 24px;
            border-radius: 20px;
            font-size: 1.5rem;
            font-weight: 700;
            border: 2px solid var(--primary-dark);
            box-shadow: 0 4px 15px rgba(0, 168, 255, 0.4);
            letter-spacing: 0.5px;
            color: var(--primary);
        }
        
        #progress-display {
            background: rgba(0, 20, 40, 0.8);
            padding: 6px 16px;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 600;
            border: 1px solid rgba(0, 168, 255, 0.3);
            color: #a0d2ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #progress-bar {
            width: 80px;
            height: 6px;
            background: rgba(0, 30, 60, 0.8);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(0, 168, 255, 0.3);
        }
        
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-dark), var(--primary));
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--primary);
        }
        
        #buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .btn {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 50, 100, 0.85));
            color: #fff;
            border: 2px solid var(--primary-dark);
            border-radius: 16px;
            padding: 10px 20px;
            font-size: 1.05rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 168, 255, 0.3);
            min-width: 95px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.95), rgba(0, 80, 150, 0.9));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 168, 255, 0.5);
            border-color: var(--primary);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .hint-btn.used {
            background: linear-gradient(135deg, rgba(60, 30, 80, 0.95), rgba(80, 40, 120, 0.85));
            border-color: var(--secondary);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }
        
        #stats-display {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.95), rgba(20, 30, 60, 0.9));
            padding: 12px 20px;
            border-radius: 16px;
            border: 2px solid rgba(0, 168, 255, 0.3);
            display: flex;
            justify-content: space-around;
            gap: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            z-index: 5;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #a0d2ff;
            font-weight: 600;
        }
        
        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        #level-selector, #completion-screen, #code-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 25, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            border-radius: 24px;
        }
        
        #code-modal {
            position: fixed;
            border-radius: 0;
            z-index: 50;
        }
        
        .modal-title {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: var(--primary);
            text-shadow: 0 0 20px rgba(0, 243, 255, 0.8);
            letter-spacing: 1px;
            font-weight: 800;
        }
        
        #level-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 10px;
            max-width: 750px;
            width: 95%;
            max-height: 65vh;
            overflow-y: auto;
            padding: 16px;
            background: rgba(10, 20, 40, 0.5);
            border-radius: 16px;
            border: 1px solid rgba(0, 168, 255, 0.2);
        }
        
        .level-btn {
            aspect-ratio: 1/1;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.9), rgba(0, 50, 100, 0.8));
            border: 2px solid var(--primary-dark);
            color: #fff;
            font-weight: 700;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 168, 255, 0.3);
        }
        
        .level-btn:hover:not(.locked) {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.95), rgba(0, 80, 150, 0.9));
            transform: scale(1.08);
            box-shadow: 0 6px 20px rgba(0, 168, 255, 0.6);
        }
        
        .level-btn.locked {
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.8), rgba(40, 40, 60, 0.7));
            color: #666;
            border-color: #444;
            cursor: not-allowed;
        }
        
        .level-btn.current {
            background: linear-gradient(135deg, rgba(0, 100, 180, 1), rgba(0, 150, 255, 0.95));
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.9);
            transform: scale(1.12);
        }
        
        .completion-title {
            font-size: 3.2rem;
            color: var(--primary);
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 243, 255, 1);
            text-align: center;
            letter-spacing: 2px;
            font-weight: 900;
        }
        
        .completion-text {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #a0d2ff;
            text-align: center;
            max-width: 85%;
            line-height: 1.5;
            font-weight: 600;
        }
        
        #next-level-btn {
            background: linear-gradient(135deg, rgba(0, 100, 180, 0.95), rgba(0, 150, 255, 0.9));
            color: #fff;
            border: 3px solid var(--primary);
            border-radius: 30px;
            padding: 16px 50px;
            font-size: 1.6rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 25px rgba(0, 243, 255, 0.6);
        }
        
        #next-level-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 35px rgba(0, 243, 255, 0.8);
        }
        
        #instructions {
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.95), rgba(20, 30, 60, 0.9));
            padding: 20px 24px;
            border-radius: 20px;
            margin-top: 10px;
            max-width: 800px;
            text-align: center;
            border: 2px solid rgba(0, 168, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 168, 255, 0.3);
            font-size: 1.05rem;
            line-height: 1.7;
            z-index: 1;
        }
        
        .highlight {
            color: var(--primary);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
        }
        
        .modal-content {
            background: linear-gradient(145deg, rgba(10, 20, 40, 0.98), rgba(20, 30, 60, 0.95));
            border-radius: 24px;
            padding: 35px;
            max-width: 500px;
            width: 90%;
            border: 2px solid var(--primary-dark);
            box-shadow: 0 10px 40px rgba(0, 168, 255, 0.5);
        }
        
        #code-input {
            width: 100%;
            padding: 18px;
            margin: 20px 0;
            border-radius: 16px;
            border: 3px solid var(--primary-dark);
            background: rgba(0, 15, 35, 0.9);
            color: white;
            font-size: 2rem;
            text-align: center;
            letter-spacing: 10px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            box-shadow: 0 4px 20px rgba(0, 168, 255, 0.4);
        }
        
        #code-input:focus {
            outline: none;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.8);
            border-color: var(--primary);
        }
        
        #code-submit {
            background: linear-gradient(135deg, rgba(0, 80, 150, 0.95), rgba(0, 120, 200, 0.9));
            color: #fff;
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 14px 35px;
            font-size: 1.4rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 243, 255, 0.5);
        }
        
        #code-submit:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(0, 243, 255, 0.7);
        }
        
        #code-message {
            margin-top: 20px;
            font-size: 1.15rem;
            text-align: center;
            min-height: 30px;
            color: var(--error);
            font-weight: 700;
        }
        
        .level-code {
            display: inline-block;
            background: rgba(0, 50, 100, 0.8);
            padding: 4px 12px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            margin: 0 4px;
            letter-spacing: 2px;
            border: 1px solid var(--primary-dark);
        }
        
        .hint-number {
            position: absolute;
            background: linear-gradient(135deg, #ffff00, #ffcc00);
            color: #000;
            font-weight: 800;
            font-size: 1.4rem;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translate(-50%, -50%);
            border: 3px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 0, 1);
            z-index: 15;
        }
        
        #hint-timer {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(60, 30, 80, 0.95), rgba(80, 40, 120, 0.9));
            color: var(--secondary);
            padding: 10px 24px;
            border-radius: 24px;
            font-weight: 700;
            font-size: 1.3rem;
            border: 2px solid var(--secondary);
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.6);
            display: none;
            z-index: 25;
        }
        
        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 85, 85, 0.2);
            border: 2px solid rgba(255, 85, 85, 0.5);
            color: #ff5555;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: 700;
            transition: all 0.3s;
        }
        
        .close-btn:hover {
            background: rgba(255, 85, 85, 0.4);
            transform: scale(1.1);
        }
        
        @media (max-width: 768px) {
            .modal-title { font-size: 2rem; }
            #level-grid { grid-template-columns: repeat(5, 1fr); }
            .completion-title { font-size: 2.5rem; }
        }
        
        @media (max-width: 480px) {
            #level-grid { grid-template-columns: repeat(4, 1fr); }
            .btn { padding: 8px 16px; font-size: 0.95rem; min-width: 80px; }
        }
        
        body.no-scroll {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container">
            <div id="level-info">
                <div id="level-display">Level: 1</div>
                <div id="progress-display">
                    <span id="progress-text">0/0</span>
                    <div id="progress-bar"><div id="progress-fill"></div></div>
                </div>
            </div>
            <div id="buttons">
                <button id="reset-btn" class="btn">â†º Reset</button>
                <button id="hint-btn" class="btn hint-btn">ðŸ’¡ Hint</button>
                <button id="selector-btn" class="btn">â‰¡ Levels</button>
                <button id="code-btn" class="btn">ðŸ”‘ Code</button>
            </div>
        </div>
        
        <div id="stats-display">
            <div class="stat-item">
                <div class="stat-label">Completed</div>
                <div class="stat-value" id="completed-count">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total</div>
                <div class="stat-value">100</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Streak</div>
                <div class="stat-value" id="streak-count">0</div>
            </div>
        </div>
        
        <div id="hint-timer">Hint: <span id="timer-count">5</span>s</div>
        
        <div id="level-selector">
            <button class="close-btn" onclick="toggleLevelSelector()">Ã—</button>
            <h2 class="modal-title">Select Level</h2>
            <div id="level-grid"></div>
        </div>
        
        <div id="completion-screen">
            <h2 class="completion-title">ðŸŽ‰ Perfect! ðŸŽ‰</h2>
            <p class="completion-text">You've mastered this level!</p>
            <div style="margin: 20px 0; color: #a0d2ff; font-size: 1.2rem;">
                Level Code: <span id="current-level-code" class="level-code">-----</span>
            </div>
            <button id="next-level-btn">Next Level</button>
        </div>
    </div>
    
    <div id="code-modal">
        <div class="modal-content">
            <h2 style="font-size: 2.2rem; color: var(--primary); margin-bottom: 20px; text-align: center;">
                Enter Level Code
            </h2>
            <input type="text" id="code-input" maxlength="5" placeholder="00000">
            <button id="code-submit" class="btn">Unlock Level</button>
            <div id="code-message"></div>
        </div>
    </div>

    <div id="instructions">
        <p>Draw over <span class="highlight">every line</span> without lifting your finger and without retracing.</p>
        <p>Use <span class="highlight">Hint</span> to see the first 6 steps of the solution!</p>
    </div>

    <script>
        let currentLevel = 0;
        let unlockedLevels = 1;
        let completedLevels = 0;
        let currentStreak = 0;
        let bestStreak = 0;
        let nodes = [];
        let edges = [];
        let drawnEdges = new Set();
        let isDrawing = false;
        let lastNode = null;
        let path = [];
        let trailParticles = [];
        let lastPoint = null;
        let levelCodes = {};
        let hintUsed = false;
        let hintPath = [];
        let hintTimer = null;
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const levelDisplay = document.getElementById('level-display');
        const progressText = document.getElementById('progress-text');
        const progressFill = document.getElementById('progress-fill');
        const completedCount = document.getElementById('completed-count');
        const streakCount = document.getElementById('streak-count');
        const resetBtn = document.getElementById('reset-btn');
        const hintBtn = document.getElementById('hint-btn');
        const selectorBtn = document.getElementById('selector-btn');
        const codeBtn = document.getElementById('code-btn');
        const levelSelector = document.getElementById('level-selector');
        const levelGrid = document.getElementById('level-grid');
        const completionScreen = document.getElementById('completion-screen');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const currentLevelCodeDisplay = document.getElementById('current-level-code');
        const codeModal = document.getElementById('code-modal');
        const codeInput = document.getElementById('code-input');
        const codeSubmit = document.getElementById('code-submit');
        const codeMessage = document.getElementById('code-message');
        const hintTimerElement = document.getElementById('hint-timer');
        const timerCountElement = document.getElementById('timer-count');
        const body = document.body;
        
        const COLORS = {
            node: '#a0d2ff',
            edge: '#5a6986',
            drawnEdge: '#00f3ff',
            currentStroke: 'rgba(0, 243, 255, 0.7)',
            particle: '#00f3ff'
        };
        
        class DeterministicRandom {
            constructor(seed) {
                this.seed = seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }
            next() {
                return this.seed = this.seed * 16807 % 2147483647;
            }
            nextFloat() {
                return (this.next() - 1) / 2147483646;
            }
            nextInt(min, max) {
                return Math.floor(this.nextFloat() * (max - min + 1)) + min;
            }
        }
        
        function generateLevelCode(levelIndex) {
            const seed = (levelIndex + 1) * 7391461 + 1987365;
            const random = new DeterministicRandom(seed);
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += random.nextInt(0, 9);
            }
            return code;
        }
        
        function generateLevelCodes() {
            levelCodes = {};
            for (let levelIndex = 4; levelIndex < 100; levelIndex++) {
                const code = generateLevelCode(levelIndex);
                levelCodes[code] = levelIndex;
            }
            return levelCodes;
        }
        
        function getLevelCode(levelIndex) {
            if (levelIndex < 4) return null;
            for (const [code, index] of Object.entries(levelCodes)) {
                if (index === levelIndex) return code;
            }
            return generateLevelCode(levelIndex);
        }
        
        const PREDEFINED_LEVELS = [
            // Level 1: Triangle (3 nodes, all degree 2) âœ“
            {
                nodes: [{x: 0.5, y: 0.25}, {x: 0.25, y: 0.75}, {x: 0.75, y: 0.75}],
                edges: [[0, 1], [1, 2], [2, 0]],
                description: "Triangle"
            },
            // Level 2: Square (4 nodes, all degree 2) âœ“
            {
                nodes: [{x: 0.3, y: 0.3}, {x: 0.7, y: 0.3}, {x: 0.7, y: 0.7}, {x: 0.3, y: 0.7}],
                edges: [[0, 1], [1, 2], [2, 3], [3, 0]],
                description: "Square"
            },
            // Level 3: House (5 nodes, 2 with odd degree) âœ“
            {
                nodes: [{x: 0.3, y: 0.7}, {x: 0.7, y: 0.7}, {x: 0.7, y: 0.4}, {x: 0.3, y: 0.4}, {x: 0.5, y: 0.15}],
                edges: [[0, 1], [1, 2], [2, 4], [4, 3], [3, 0], [2, 3]],
                description: "House"
            },
            // Level 4: Pentagon (5 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.15}, {x: 0.85, y: 0.35}, {x: 0.75, y: 0.75}, 
                    {x: 0.25, y: 0.75}, {x: 0.15, y: 0.35}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]],
                description: "Pentagon"
            },
            // Level 5: Hexagon (6 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.15}, {x: 0.8, y: 0.3}, {x: 0.8, y: 0.7},
                    {x: 0.5, y: 0.85}, {x: 0.2, y: 0.7}, {x: 0.2, y: 0.3}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]],
                description: "Hexagon"
            },
            // Level 6: Envelope (5 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.2, y: 0.3}, {x: 0.8, y: 0.3}, {x: 0.8, y: 0.7},
                    {x: 0.2, y: 0.7}, {x: 0.5, y: 0.5}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 4]],
                description: "Envelope"
            },
            // Level 7: Bowtie (5 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.2, y: 0.2}, {x: 0.5, y: 0.5}, {x: 0.2, y: 0.8},
                    {x: 0.8, y: 0.2}, {x: 0.8, y: 0.8}
                ],
                edges: [[0, 1], [1, 2], [2, 0], [1, 3], [1, 4], [3, 4]],
                description: "Bowtie"
            },
            // Level 8: Star (10 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.15}, {x: 0.7, y: 0.45}, {x: 0.95, y: 0.45}, 
                    {x: 0.75, y: 0.65}, {x: 0.85, y: 0.95}, {x: 0.5, y: 0.75}, 
                    {x: 0.15, y: 0.95}, {x: 0.25, y: 0.65}, {x: 0.05, y: 0.45}, 
                    {x: 0.3, y: 0.45}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 0]],
                description: "Star"
            },
            // Level 9: Double Square (8 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.25, y: 0.25}, {x: 0.5, y: 0.25}, {x: 0.75, y: 0.25}, {x: 0.75, y: 0.5},
                    {x: 0.75, y: 0.75}, {x: 0.5, y: 0.75}, {x: 0.25, y: 0.75}, {x: 0.25, y: 0.5}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0]],
                description: "Double Square"
            },
            // Level 10: Octagon (8 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.15}, {x: 0.75, y: 0.25}, {x: 0.9, y: 0.5},
                    {x: 0.75, y: 0.75}, {x: 0.5, y: 0.85}, {x: 0.25, y: 0.75},
                    {x: 0.1, y: 0.5}, {x: 0.25, y: 0.25}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0]],
                description: "Octagon"
            },
            // Level 11: Simple Cross (5 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.2}, {x: 0.5, y: 0.5}, {x: 0.5, y: 0.8},
                    {x: 0.2, y: 0.5}, {x: 0.8, y: 0.5}
                ],
                edges: [[0, 1], [1, 2], [1, 3], [1, 4], [3, 4]],
                description: "Simple Cross"
            },
            // Level 12: Kite (4 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.2}, {x: 0.3, y: 0.5}, {x: 0.7, y: 0.5}, {x: 0.5, y: 0.8}
                ],
                edges: [[0, 1], [0, 2], [1, 3], [2, 3], [1, 2]],
                description: "Kite"
            },
            // Level 13: Fish (7 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.2, y: 0.5}, {x: 0.4, y: 0.3}, {x: 0.4, y: 0.7},
                    {x: 0.6, y: 0.3}, {x: 0.6, y: 0.7}, {x: 0.8, y: 0.4}, {x: 0.8, y: 0.6}
                ],
                edges: [[0, 1], [0, 2], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 6]],
                description: "Fish"
            },
            // Level 14: Butterfly (8 nodes, all degree 2) âœ“
            {
                nodes: [
                    {x: 0.3, y: 0.3}, {x: 0.45, y: 0.5}, {x: 0.3, y: 0.7},
                    {x: 0.15, y: 0.5}, {x: 0.7, y: 0.3}, {x: 0.55, y: 0.5},
                    {x: 0.7, y: 0.7}, {x: 0.85, y: 0.5}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4]],
                description: "Butterfly"
            },
            // Level 15: Letter A (7 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.3, y: 0.8}, {x: 0.4, y: 0.5}, {x: 0.5, y: 0.2},
                    {x: 0.6, y: 0.5}, {x: 0.7, y: 0.8}, {x: 0.35, y: 0.6}, {x: 0.65, y: 0.6}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [1, 5], [5, 6], [6, 3]],
                description: "Letter A"
            },
            // Level 16: Zigzag (6 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.2, y: 0.3}, {x: 0.4, y: 0.3}, {x: 0.4, y: 0.5},
                    {x: 0.6, y: 0.5}, {x: 0.6, y: 0.7}, {x: 0.8, y: 0.7}
                ],
                edges: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]],
                description: "Zigzag"
            },
            // Level 17: Diamond Chain (6 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.2, y: 0.5}, {x: 0.35, y: 0.3}, {x: 0.35, y: 0.7},
                    {x: 0.5, y: 0.5}, {x: 0.65, y: 0.3}, {x: 0.65, y: 0.7}
                ],
                edges: [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [3, 5], [4, 5]],
                description: "Diamond Chain"
            },
            // Level 18: Tree (7 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.8}, {x: 0.5, y: 0.6}, {x: 0.35, y: 0.4},
                    {x: 0.65, y: 0.4}, {x: 0.25, y: 0.2}, {x: 0.5, y: 0.2}, {x: 0.75, y: 0.2}
                ],
                edges: [[0, 1], [1, 2], [1, 3], [2, 4], [2, 5], [3, 5], [3, 6]],
                description: "Tree"
            },
            // Level 19: Hourglass (6 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.3, y: 0.2}, {x: 0.7, y: 0.2}, {x: 0.5, y: 0.5},
                    {x: 0.3, y: 0.8}, {x: 0.7, y: 0.8}, {x: 0.5, y: 0.35}
                ],
                edges: [[0, 1], [0, 2], [1, 2], [2, 3], [2, 4], [3, 4]],
                description: "Hourglass"
            },
            // Level 20: Complex Web (9 nodes, 2 with odd degree) âœ“
            {
                nodes: [
                    {x: 0.5, y: 0.2}, {x: 0.3, y: 0.4}, {x: 0.7, y: 0.4},
                    {x: 0.2, y: 0.6}, {x: 0.5, y: 0.6}, {x: 0.8, y: 0.6},
                    {x: 0.3, y: 0.8}, {x: 0.7, y: 0.8}, {x: 0.5, y: 0.5}
                ],
                edges: [[0, 1], [0, 2], [1, 3], [2, 5], [3, 4], [4, 5], [3, 6], [5, 7], [6, 7], [1, 8], [2, 8]],
                description: "Web"
            }
        ];
        
        function generateGridPattern(rows, cols) {
            const nodes = [];
            const edges = [];
            const spacingX = 0.8 / (cols + 1);
            const spacingY = 0.8 / (rows + 1);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols - 1; j++) {
                    edges.push([i * cols + j, i * cols + j + 1]);
                }
            }
            
            for (let i = 0; i < rows - 1; i++) {
                for (let j = 0; j < cols; j++) {
                    edges.push([i * cols + j, (i + 1) * cols + j]);
                }
            }
            
            return { nodes, edges, description: `Grid ${rows}x${cols}` };
        }
        
        function generateAllLevels() {
            const allLevels = [...PREDEFINED_LEVELS];
            
            for (let i = 6; i <= 100; i++) {
                const rows = 2 + Math.floor(i / 20);
                const cols = 2 + Math.floor(i / 25);
                allLevels.push(generateGridPattern(Math.min(rows, 5), Math.min(cols, 5)));
            }
            
            return allLevels.slice(0, 100);
        }
        
        const LEVELS = generateAllLevels();
        generateLevelCodes();
        
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 3 + 1;
                this.speedX = Math.random() * 2 - 1;
                this.speedY = Math.random() * 2 - 1;
                this.life = 30;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
                this.size *= 0.97;
            }
            draw(ctx) {
                ctx.fillStyle = COLORS.particle;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function findSolutionPath() {
            const graph = {};
            for (let i = 0; i < nodes.length; i++) {
                graph[i] = [];
            }
            
            edges.forEach(([a, b]) => {
                graph[a].push(b);
                graph[b].push(a);
            });
            
            const degrees = nodes.map((_, i) => graph[i].length);
            const oddDegreeNodes = degrees.map((deg, idx) => deg % 2 === 1 ? idx : -1).filter(idx => idx !== -1);
            
            let startNode = oddDegreeNodes.length === 2 ? oddDegreeNodes[0] : 0;
            
            const path = [];
            const stack = [startNode];
            const localGraph = JSON.parse(JSON.stringify(graph));
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                
                if (localGraph[current].length > 0) {
                    const next = localGraph[current].pop();
                    const index = localGraph[next].indexOf(current);
                    if (index !== -1) {
                        localGraph[next].splice(index, 1);
                    }
                    stack.push(next);
                } else {
                    path.push(stack.pop());
                }
            }
            
            return path.reverse();
        }
        
        function showHint() {
            if (hintUsed) return;
            
            hintUsed = true;
            hintBtn.classList.add('used');
            hintBtn.disabled = true;
            
            hintPath = findSolutionPath();
            
            if (hintPath.length > 0) {
                const maxHints = Math.min(6, hintPath.length);
                for (let i = 0; i < maxHints; i++) {
                    const nodeIndex = hintPath[i];
                    const node = nodes[nodeIndex];
                    const hintElement = document.createElement('div');
                    hintElement.className = 'hint-number';
                    hintElement.textContent = i + 1;
                    hintElement.style.left = `${node.x}px`;
                    hintElement.style.top = `${node.y}px`;
                    container.appendChild(hintElement);
                }
            }
            
            hintTimerElement.style.display = 'block';
            let secondsLeft = 5;
            timerCountElement.textContent = secondsLeft;
            
            hintTimer = setInterval(() => {
                secondsLeft--;
                timerCountElement.textContent = secondsLeft;
                
                if (secondsLeft <= 0) {
                    hideHint();
                }
            }, 1000);
        }
        
        function hideHint() {
            clearInterval(hintTimer);
            hintTimerElement.style.display = 'none';
            const hintElements = document.querySelectorAll('.hint-number');
            hintElements.forEach(element => element.remove());
        }
        
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseleave', endDrawing);
            
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            resetBtn.addEventListener('click', resetLevel);
            hintBtn.addEventListener('click', showHint);
            selectorBtn.addEventListener('click', toggleLevelSelector);
            codeBtn.addEventListener('click', showCodeModal);
            codeSubmit.addEventListener('click', validateCode);
            codeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') validateCode();
            });
            nextLevelBtn.addEventListener('click', nextLevel);
            
            generateLevelSelector();
            loadLevel(currentLevel);
            updateStats();
        }
        
        function showCodeModal() {
            codeModal.style.display = 'flex';
            codeInput.value = '';
            codeMessage.textContent = '';
            codeInput.focus();
            body.classList.add('no-scroll');
        }
        
        function hideCodeModal() {
            codeModal.style.display = 'none';
            body.classList.remove('no-scroll');
        }
        
        function validateCode() {
            const code = codeInput.value.trim();
            codeMessage.textContent = '';
            
            if (code.length !== 5) {
                codeMessage.textContent = 'Code must be 5 digits!';
                return;
            }
            
            if (!/^\d+$/.test(code)) {
                codeMessage.textContent = 'Only numbers allowed!';
                return;
            }
            
            if (levelCodes[code] !== undefined) {
                const targetLevel = levelCodes[code];
                
                if (targetLevel + 1 > unlockedLevels) {
                    unlockedLevels = targetLevel + 1;
                    generateLevelSelector();
                }
                
                loadLevel(targetLevel);
                
                codeMessage.style.color = 'var(--primary)';
                codeMessage.textContent = `Jumping to Level ${targetLevel + 1}...`;
                
                setTimeout(() => {
                    hideCodeModal();
                }, 1000);
            } else {
                codeMessage.textContent = 'Invalid code!';
                codeInput.value = '';
            }
        }
        
        function resizeCanvas() {
            const containerRect = container.getBoundingClientRect();
            const size = Math.min(containerRect.width, containerRect.height);
            
            canvas.width = size;
            canvas.height = size;
            
            drawLevel();
        }
        
        function toCanvasCoords(point) {
            const margin = canvas.width * 0.1;
            const usableWidth = canvas.width - 2 * margin;
            const usableHeight = canvas.height - 2 * margin;
            
            return {
                x: margin + point.x * usableWidth,
                y: margin + point.y * usableHeight
            };
        }
        
        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            levelDisplay.textContent = `Level: ${currentLevel + 1}`;
            
            const level = LEVELS[currentLevel];
            
            // Validate level data
            if (!level || !level.nodes || !level.edges) {
                console.error('Invalid level data at index', levelIndex);
                return;
            }
            
            // Validate all edges reference valid nodes
            const maxNodeIndex = level.nodes.length - 1;
            const validEdges = level.edges.filter(([a, b]) => {
                if (a > maxNodeIndex || b > maxNodeIndex || a < 0 || b < 0) {
                    console.warn(`Invalid edge [${a}, ${b}] in level ${levelIndex + 1}`);
                    return false;
                }
                return true;
            });
            
            nodes = level.nodes.map(node => toCanvasCoords(node));
            edges = validEdges;
            
            hintUsed = false;
            hintBtn.classList.remove('used');
            hintBtn.disabled = false;
            hideHint();
            
            resetLevel();
            drawLevel();
            updateProgress();
            
            levelSelector.style.display = 'none';
            hideCodeModal();
        }
        
        function resetLevel() {
            drawnEdges = new Set();
            isDrawing = false;
            lastNode = null;
            path = [];
            trailParticles = [];
            hideHint();
            drawLevel();
            updateProgress();
        }
        
        function updateProgress() {
            const total = edges.length;
            const current = drawnEdges.size;
            progressText.textContent = `${current}/${total}`;
            progressFill.style.width = `${(current / total) * 100}%`;
        }
        
        function updateStats() {
            completedCount.textContent = completedLevels;
            streakCount.textContent = bestStreak;
        }
        
        function drawLevel() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            edges.forEach(([a, b]) => {
                const edgeKey = getEdgeKey(a, b);
                const isDrawn = drawnEdges.has(edgeKey);
                ctx.strokeStyle = isDrawn ? COLORS.drawnEdge : COLORS.edge;
                ctx.lineWidth = isDrawn ? 4 : 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(nodes[a].x, nodes[a].y);
                ctx.lineTo(nodes[b].x, nodes[b].y);
                ctx.stroke();
            });
            
            nodes.forEach(node => {
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 12);
                gradient.addColorStop(0, COLORS.node);
                gradient.addColorStop(1, 'rgba(160, 210, 255, 0.2)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            if (isDrawing && path.length > 0) {
                ctx.strokeStyle = COLORS.currentStroke;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(nodes[path[0]].x, nodes[path[0]].y);
                
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(nodes[path[i]].x, nodes[path[i]].y);
                }
                
                if (lastPoint) {
                    ctx.lineTo(lastPoint.x, lastPoint.y);
                }
                
                ctx.stroke();
            }
            
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const particle = trailParticles[i];
                particle.update();
                particle.draw(ctx);
                
                if (particle.life <= 0 || particle.size < 0.5) {
                    trailParticles.splice(i, 1);
                }
            }
        }
        
        function startDrawing(e) {
            e.preventDefault();
            if (isDrawing) return;
            
            const pos = getMousePos(e);
            lastPoint = pos;
            
            let closestNode = null;
            let minDistance = 25;
            
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                const dx = node.x - pos.x;
                const dy = node.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestNode = i;
                }
            }
            
            if (closestNode !== null) {
                isDrawing = true;
                lastNode = closestNode;
                path = [closestNode];
                drawnEdges = new Set();
                trailParticles = [];
            }
        }
        
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                e.preventDefault();
                startDrawing(e.touches[0]);
                body.classList.add('no-scroll');
            }
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        }
        
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getMousePos(e);
            drawSegment(pos);
        }
        
        function handleTouchMove(e) {
            if (!isDrawing || e.touches.length !== 1) return;
            e.preventDefault();
            
            const pos = getTouchPos(e);
            drawSegment(pos);
        }
        
        function drawSegment(pos) {
            if (!lastPoint) {
                lastPoint = pos;
                return;
            }
            
            const dx = pos.x - lastPoint.x;
            const dy = pos.y - lastPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                const steps = Math.floor(distance / 5);
                for (let i = 1; i <= steps; i++) {
                    const x = lastPoint.x + (dx * i / steps);
                    const y = lastPoint.y + (dy * i / steps);
                    trailParticles.push(new Particle(x, y));
                }
            }
            
            let closestNode = null;
            let minDistance = 30;
            
            for (let i = 0; i < nodes.length; i++) {
                if (i === lastNode) continue;
                
                const node = nodes[i];
                const dx = node.x - pos.x;
                const dy = node.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    const edgeKey = getEdgeKey(lastNode, i);
                    if (hasEdge(lastNode, i) && !drawnEdges.has(edgeKey)) {
                        minDistance = distance;
                        closestNode = i;
                    }
                }
            }
            
            if (closestNode !== null) {
                const edgeKey = getEdgeKey(lastNode, closestNode);
                drawnEdges.add(edgeKey);
                path.push(closestNode);
                lastNode = closestNode;
                lastPoint = {x: nodes[closestNode].x, y: nodes[closestNode].y};
                updateProgress();
            } else {
                lastPoint = pos;
            }
            
            drawLevel();
            checkLevelCompletion();
        }
        
        function checkLevelCompletion() {
            if (drawnEdges.size === edges.length) {
                setTimeout(showCompletionScreen, 300);
            }
        }
        
        function showCompletionScreen() {
            isDrawing = false;
            
            if (currentLevel + 1 < LEVELS.length && currentLevel + 2 > unlockedLevels) {
                unlockedLevels = currentLevel + 2;
                generateLevelSelector();
            }
            
            completedLevels++;
            currentStreak++;
            if (currentStreak > bestStreak) {
                bestStreak = currentStreak;
            }
            updateStats();
            
            if (currentLevel >= 4) {
                const code = getLevelCode(currentLevel);
                currentLevelCodeDisplay.textContent = code || '00000';
            } else {
                currentLevelCodeDisplay.textContent = '-----';
            }
            
            completionScreen.style.display = 'flex';
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            lastPoint = null;
            
            if (drawnEdges.size < edges.length) {
                setTimeout(resetLevel, 200);
            }
        }
        
        function handleTouchEnd() {
            endDrawing();
            body.classList.remove('no-scroll');
        }
        
        function getEdgeKey(a, b) {
            return a < b ? `${a}-${b}` : `${b}-${a}`;
        }
        
        function hasEdge(a, b) {
            return edges.some(edge => 
                (edge[0] === a && edge[1] === b) || 
                (edge[0] === b && edge[1] === a)
            );
        }
        
        function toggleLevelSelector() {
            levelSelector.style.display = 
                levelSelector.style.display === 'flex' ? 'none' : 'flex';
            
            if (levelSelector.style.display === 'flex') {
                body.classList.add('no-scroll');
            } else {
                body.classList.remove('no-scroll');
            }
        }
        
        function generateLevelSelector() {
            levelGrid.innerHTML = '';
            
            for (let i = 0; i < LEVELS.length; i++) {
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                btn.textContent = i + 1;
                
                if (i + 1 > unlockedLevels) {
                    btn.classList.add('locked');
                }
                
                if (i === currentLevel) {
                    btn.classList.add('current');
                }
                
                btn.addEventListener('click', () => {
                    if (i + 1 <= unlockedLevels) {
                        loadLevel(i);
                        body.classList.remove('no-scroll');
                    }
                });
                
                levelGrid.appendChild(btn);
            }
        }
        
        function nextLevel() {
            completionScreen.style.display = 'none';
            
            if (currentLevel + 1 < LEVELS.length) {
                loadLevel(currentLevel + 1);
            } else {
                loadLevel(0);
            }
        }
        
        window.onload = init;
        
        window.addEventListener('click', function(e) {
            if (e.target === codeModal) {
                hideCodeModal();
            }
            if (e.target === levelSelector) {
                toggleLevelSelector();
            }
        });
    </script>
</body>
</html>